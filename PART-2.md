Подготовка к устному зачету по курсу «Алгоритмы и структуры данных», вторая часть.

## Список билетов
### 1. Хеширование. Полиномиальная хеш-функция. Алгоритм Рабина-Карпа. Оценка времени выполнения.

**Хеширование** - это процесс преобразования входных данных произвольной длины в строку фиксированной длины. **Хеш-функция** - это функция, которая осуществляет данное преобразование.

**Полиномиальная хеш-функция** - это хеш-функция, которая использует для преобразования полиномиальное выражение. Полиномиальное выражение - это выражение следующего вида:

**P(x) = a<sub>0</sub> + a<sub>1</sub> * x + a<sub>2</sub> * x<sup>2</sup> + ... + a<sub>n-1</sub> * x<sup>n-1</sup> + a<sub>n</sub> * x<sup>n</sup>**,  
где **a<sub>0</sub>-a<sub>n</sub>** - коэффициенты, **n** - степень полинома.

Пример полиномиальной хеш-функции:

**hash(s) = s[0] + s[1] * p + s[2] * p<sup>2</sup> + ... + s[n-1] * p<sup>n-1</sup> + s[n] * p<sup>n</sup>**,  
где **s** - строка, **s[i]** - i-й символ строки, **n** - длина строки, **p** - простое число. Для более компактного представления хешей обычно берут остаток от деления представленного выше выражения на некоторое число **r**. Это ограничивает диапазон хешей от **0** до **(r - 1)** и помогает избежать переполнений, однако может привести к **коллизиям** - ситуациям, когда двум разным входным значениям соответствует один и тот же хеш.

**Алгоритм Рабина-Карпа** - это алгоритм для поиска подстроки в строке с использованием хеширования. Пусть дана строка ```s``` длины ```n``` и искомая подстрока ```w``` длины ```m <= n```. Алгоритм будет работать следующим образом:

1. Вычислить хеш искомой подстроки ```w``` и всех возможных подстрок длины ```m``` в исходной строке.
2. Сравнить хеш ```w``` с хешами этих подстрок.
3. Вернуть список индексов, где было найдено совпадение.

Пример реализации алгоритма на Java:

```java
import java.util.ArrayList;
import java.util.List;

public class RabinKarpAlgorithm {
    private static final int p = 256; // Размер алфавита (количество символов, которые могут встречаться в строках s и w).
    private static final int r = 101; // Число для остатка от деления.
    
    public static List<Integer> rabinKarp(String s, String w) {
        List<Integer> answer = new ArrayList<>(); // Список совпадений.

        int n = s.length();
        int m = w.length();

        int hashS = hash(s.substring(0, m)); // Вычисляем хеш для первой подстроки длины m в строке s.
        int hashW = hash(w.substring(0, m)); // Вычисляем хеш для подстроки w.

        for (int i = 0; i <= n - m; i++) {
            // Проверка равенства хешей.
            if (hashS == hashW) {
                answer.add(i);
            }
            if (i < n - m) {
                // Пересчитываем хеш для следующей подстроки (сдвиг по s на 1 символ вперед).
                hashS = (p * hashS - (int) Math.pow(p, m) * hash(s.charAt(i)) + hash(s.charAt(i + m))) % r;
            }
        }
        
        return answer;
    }

    private static int hash(String str) {
        // Хеш-функция вида hash(t) = t[n] + t[n-1] * p + t[n-2] * p^2 + ... + t[1] * p^(n-1) + t[0] * p^n.
    }
}
```
Изначальный подсчёт хешей выполняется за ```O(m)```. Каждая итерация выполняется за ```O(1)```, В цикле всего ```n − m + 1``` итераций. Таким образом, итоговое время работы алгоритма без дополнительных проверок ```O(n + m)```. Однако, если требуется исключить ложные срабатывания алгоритма полностью (они могут возникнуть в случае коллизий), придется проверить все полученные позиции вхождений на истинность. Получаем ```O(n * m)``` в худшем случае.

### 2. Z-функция. Пи-функция. Определения. Алгоритмы построения. Оценка времени выполнения.

**Z-функция** для данной строки ```S``` длины ```n``` - это массив ```Z[1..n]```, такой что его элемент ```Z[i]``` равен наибольшей длине префикса подстроки ```S```, начинающейся с позиции ```i```, которая также является префиксом самой строки ```S```. Значение Z-функции от первой позиции не определено, поэтому его обычно приравнивают к нулю или к длине строки.

Алгоритм построения:

**Pi-функция** для данной строки ```S``` длины ```n``` - это массив ```Pi[1..n]```, такой что его элемент ```Pi[i]``` равен наибольшей длине суффикса подстроки ```S[1..i]```, который также является префиксом строки ```S```.

### 3. Алгоритм Дейкстры. Постановка задачи, описание алгоритма за O(V<sup>2</sup> + E). Улучшение алгоритма для разреженных графов за O(E log V).
### 4. Динамическое программирование. Основные понятия. Задача о кузнечике. Задача о черепашке.
### 5. Задача о рюкзаке: постановка классической задачи, решение методом динамического программирования, оценка времени работы.
### 6. Задача поиска наибольшей возрастающей подпоследовательности в массиве. Решение за O(N<sup>2</sup>) методом динамического программирования. Решение за O(N log N) методом динамического программирования.
### 7. Задача поиска длины наибольшей общей подпоследовательности двух строк. Решение за O(N * M) методом динамического программирования.
### 8. Поиск суммы на отрезке + изменение значения в массиве. Постановка задачи, решение за O(log N) при помощи дерева отрезков. Построение дерева отрезков.
### 9. Поиск минимума на отрезке + изменение значения в массиве. Постановка задачи, решение за O(log N) при помощи дерева отрезков. Построение дерева отрезков.
### 10. Алгоритм Форда-Беллмана. Описание алгоритма. Оценка времени выполнения.
### 11. Алгоритм Флойда-Уоршелла. Описание алгоритма. Оценка времени выполнения.
### 12. Двоичные деревья поиска. Описание структуры. Операции: постороения, удаления, вставки. Асимптотика операций.
