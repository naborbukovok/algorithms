Подготовка к устному зачету по курсу «Алгоритмы и структуры данных», вторая часть.

## Список билетов
### 1. Хеширование. Полиномиальная хеш-функция. Алгоритм Рабина-Карпа. Оценка времени выполнения.

**Хеширование** - это процесс преобразования входных данных произвольной длины в строку фиксированной длины. **Хеш-функция** - это функция, которая осуществляет данное преобразование.

**Полиномиальная хеш-функция** - это хеш-функция, которая использует для преобразования полиномиальное выражение. Полиномиальное выражение - это выражение следующего вида:

**P(x) = a<sub>0</sub> + a<sub>1</sub> * x + a<sub>2</sub> * x<sup>2</sup> + ... + a<sub>n-1</sub> * x<sup>n-1</sup> + a<sub>n</sub> * x<sup>n</sup>**,  
где **a<sub>0</sub>-a<sub>n</sub>** - коэффициенты, **n** - степень полинома.

Получаем пример полиномиальной хеш-функции:

**hash(s) = s[0] + s[1] * p + s[1] * p<sup>2</sup> + ... + s[n-1] * p<sup>n-1</sup> + s[n] * p<sup>n</sup>**,  
где **s** - строка, **s[i]** - i-й символ строки, **n** - длина строки, **p** - простое число. Для более компактного представления хешей обычно берут остаток от деления представленного выше выражения на некоторое число **r**. Это ограничивает диапазон хешей от **0** до **(r - 1)** и помогает избежать переполнений, однако может привести к **коллизиям** - ситуациям, когда двум разным входным значениям соответствует один и тот же хеш.

**Алгоритм Рабина-Карпа** - это алгоритм для поиска подстроки в строке с использованием хеширования. Пусть дана строка ```s``` длины ```n``` и искомая подстрока ```w``` длины ```m```. Алгоритм будет работать следующим образом:

1. Вычислить хеш искомой подстроки ```w``` и всех возможных подстрок длины ```m``` в исходной строке.
2. Сравнить хеш ```w``` с хешами этих подстрок. Если хеши совпадают, для проверки сравнить сами строки (чтобы избежать коллизий).
3. Вернуть список индексов, где было найдено совпадение.

Пример реализации алгоритма на Java:

```java
import java.util.ArrayList;
import java.util.List;

public class RabinKarpAlgorithm {
    private static final int R = 256; // Радикс (размер алфавита)
    private static final int R_MOD = 101; // Некоторое большое простое число

    public static List<Integer> rabinKarp(String s, String w) {
        List<Integer> answer = new ArrayList<>();

        int n = s.length();
        int m = w.length();

        int hashS = hash(s.substring(0, m));
        int hashW = hash(w.substring(0, m));

        for (int i = 0; i <= n - m; i++) {
            if (hashS == hashW) {
                answer.add(i);
            }
            if (i < n - m) {
                hashS = (R * (hashS - (int) Math.pow(R, m - 1) * s.charAt(i)) + s.charAt(i + m)) % R_MOD;
                hashS = (hashS + R_MOD) % R_MOD;
            }
        }

        return answer;
    }

    private static int hash(String str) {
        int hash = 0;
        int len = str.length();
        for (int i = 0; i < len; i++) {
            hash = (R * hash + str.charAt(i)) % R_MOD;
        }
        return hash;
    }
}
```

### 2. Z-функция. Пи-функция. Определения. Алгоритмы построения. Оценка времени выполнения.
### 3. Алгоритм Дейкстры. Постановка задачи, описание алгоритма за O(V<sup>2</sup> + E). Улучшение алгоритма для разреженных графов за O(E log V).
### 4. Динамическое программирование. Основные понятия. Задача о кузнечике. Задача о черепашке.
### 5. Задача о рюкзаке: постановка классической задачи, решение методом динамического программирования, оценка времени работы.
### 6. Задача поиска наибольшей возрастающей подпоследовательности в массиве. Решение за O(N<sup>2</sup>) методом динамического программирования. Решение за O(N log N) методом динамического программирования.
### 7. Задача поиска длины наибольшей общей подпоследовательности двух строк. Решение за O(N * M) методом динамического программирования.
### 8. Поиск суммы на отрезке + изменение значения в массиве. Постановка задачи, решение за O(log N) при помощи дерева отрезков. Построение дерева отрезков.
### 9. Поиск минимума на отрезке + изменение значения в массиве. Постановка задачи, решение за O(log N) при помощи дерева отрезков. Построение дерева отрезков.
### 10. Алгоритм Форда-Беллмана. Описание алгоритма. Оценка времени выполнения.
### 11. Алгоритм Флойда-Уоршелла. Описание алгоритма. Оценка времени выполнения.
### 12. Двоичные деревья поиска. Описание структуры. Операции: постороения, удаления, вставки. Асимптотика операций.
