Подготовка к устному зачету по курсу «Алгоритмы и структуры данных», вторая часть.

## Список билетов
### 1. Хеширование. Полиномиальная хеш-функция. Алгоритм Рабина-Карпа. Оценка времени выполнения.

**Хеширование** - это процесс преобразования входных данных произвольной длины в строку фиксированной длины. **Хеш-функция** - это функция, которая осуществляет данное преобразование.

**Полиномиальная хеш-функция** - это хеш-функция, которая использует для преобразования полиномиальное выражение. Полиномиальное выражение - это выражение следующего вида:

**P(x) = a<sub>0</sub> + a<sub>1</sub> * x + a<sub>2</sub> * x<sup>2</sup> + ... + a<sub>n-1</sub> * x<sup>n-1</sup> + a<sub>n</sub> * x<sup>n</sup>**,  
где **a<sub>0</sub>-a<sub>n</sub>** - коэффициенты, **n** - степень полинома.

Пример полиномиальной хеш-функции:

**hash(s) = s[0] + s[1] * p + s[2] * p<sup>2</sup> + ... + s[n-1] * p<sup>n-1</sup> + s[n] * p<sup>n</sup>**,  
где **s** - строка, **s[i]** - i-й символ строки, **n** - длина строки, **p** - простое число. Для более компактного представления хешей обычно берут остаток от деления представленного выше выражения на некоторое число **r**. Это ограничивает диапазон хешей от **0** до **(r - 1)** и помогает избежать переполнений, однако может привести к **коллизиям** - ситуациям, когда двум разным входным значениям соответствует один и тот же хеш.

**Алгоритм Рабина-Карпа** - это алгоритм для поиска подстроки в строке с использованием хеширования. Пусть дана строка ```s``` длины ```n``` и искомая подстрока ```w``` длины ```m <= n```. Алгоритм будет работать следующим образом:

1. Вычислить хеш искомой подстроки ```w``` и всех возможных подстрок длины ```m``` в исходной строке.
2. Сравнить хеш ```w``` с хешами этих подстрок.
3. Вернуть список индексов, где было найдено совпадение.

Пример реализации алгоритма на Java:

```java
import java.util.ArrayList;
import java.util.List;

public class RabinKarpAlgorithm {
    private static final int p = 256; // Размер алфавита (количество символов, которые могут встречаться в строках s и w).
    private static final int r = 101; // Число для остатка от деления.
    
    public static List<Integer> rabinKarp(String s, String w) {
        List<Integer> answer = new ArrayList<>(); // Список совпадений.

        int n = s.length();
        int m = w.length();

        int hashS = hash(s.substring(0, m)); // Вычисляем хеш для первой подстроки длины m в строке s.
        int hashW = hash(w.substring(0, m)); // Вычисляем хеш для подстроки w.

        for (int i = 0; i <= n - m; i++) {
            // Проверка равенства хешей.
            if (hashS == hashW) {
                answer.add(i);
            }
            if (i < n - m) {
                // Пересчитываем хеш для следующей подстроки (сдвиг по s на 1 символ вперед).
                hashS = (p * hashS - (int) Math.pow(p, m) * hash(s.charAt(i)) + hash(s.charAt(i + m))) % r;
            }
        }
        
        return answer;
    }

    private static int hash(String str) {
        // Хеш-функция вида hash(t) = t[n] + t[n-1] * p + t[n-2] * p^2 + ... + t[1] * p^(n-1) + t[0] * p^n.
    }
}
```
Изначальный подсчёт хешей выполняется за ```O(m)```. Каждая итерация выполняется за ```O(1)```, В цикле всего ```n − m + 1``` итераций. Таким образом, итоговое время работы алгоритма без дополнительных проверок ```O(n + m)```. Однако, если требуется исключить ложные срабатывания алгоритма полностью (они могут возникнуть в случае коллизий), придется проверить все полученные позиции вхождений на истинность. Получаем ```O(n * m)``` в худшем случае.

### 2. Z-функция. Пи-функция. Определения. Алгоритмы построения. Оценка времени выполнения.

**Z-функция** для данной строки ```s``` длины ```n``` - это массив ```z[0..(n-1)]```, такой что его элемент ```z[i]``` равен наибольшей длине префикса подстроки ```s```, начинающейся с позиции ```i```, которая также является префиксом самой строки ```s```. Значение z-функции в начальной позиции не определено, поэтому его обычно приравнивают к нулю или к длине строки.

Рассмотрим **тривиальный алгоритм** построения.

Пример реализации тривиального алгоритма на Java: 

```java
public static int[] trivialZ(String s) {
    int n = s.length();
    int[] z = new int[n];
    for (int i = 1; i < n; ++i) {
        while (i + z[i] < n && s.charAt(z[i]) == s.charAt(i + z[i])) {
            ++z[i];
        }
    }
    return z;
}
```

Тривиальный алгоритм базируется на определении и имеет сложность ```O(n^2)```, где ```n``` - длина строки.

Перейдем к **эффективному алгоритму**. Будем вычислять значения ```z[i]``` по очереди — от ```i = 1``` до ```i = n - 1```, и при этом постараемся при вычислении очередного значения ```z[i]``` максимально использовать уже вычисленные значения. Для этого будем хранить ```L``` и ```R``` - координаты начала и конца самой правой подстроки, которая является префиксом s, из уже рассмотренных. Изначально ```L = 0```, ```R = 0```. Далее для каждого i выполним одно из действий:

1. Если ```i > R```:  
Будем искать ```z[i]``` тривиальным алгоритмом. Если ```z[i] > 0```, обновим ```L``` и ```R```.
2. Если ```i <= R```:  
Можно использовать предыдущие полученные значения z-функции. Так как ```z[L..R]``` и ```z[0, R - L]``` совтпадают, ```z[i]``` может соответствовать ```z[i - L]```. Кроме того, от текущего элемента до конца известного отрезка ```[L, R]``` остается ```r - i + 1``` элементов. Чтобы не выйти за границы массива, как начальное значение возьмем минимум из ```z[i - L]``` и ```r - i + 1```. Далее, начиная с этого значения, пойдем тривиальным алгоритмом.

Пример реализации эффективного алгоритма на Java: 

```java
public static int[] effectiveZ(String s) {
    int n = s.length();
    int[] z = new int[n];
    int l = 0, r = 0;
    for (int i = 1; i < n; ++i) {
        if (i <= r) {
            z[i] = Math.min(r - i + 1, z[i - l]);
        }
        while (i + z[i] < n && s.charAt(z[i]) == s.charAt(i + z[i])) {
            ++z[i];
        }
        if (i + z[i] - 1 > r) {
            l = i;
            r = i + z[i] - 1;
        }
    }
    return z;
}
```

Внутри цикла ```for``` эффективного алгоритма все кроме ```while``` работает за константное время. Но каждая итерация ```while``` приводит к передвижению ```R``` вправо на 1. Так как ```R``` не может быть больше ```n - 1``` (это индекс последнего элемента массива ```z```). Таким образом, всего в ```while``` будет не более ```n - 1``` операций суммарно. Получаем итоговую сложность алгоритма ```O(n)```.

**Pi-функция** для данной строки ```s``` длины ```n``` - это массив ```pi[0..(n-1)]```, такой что его элемент ```pi[i]``` равен наибольшей длине наибольшего собственного суффикса подстроки ```s[0..i]```, который также является её префиксом. Если такого собственного суффикса не найдено, то значение pi-функции в этой позиции равно 0.

Рассмотрим **тривиальный алгоритм** построения.

Пример реализации тривиального алгоритма на Java: 

```java
public static int[] trivialPi(String s) {
    int n = s.length();
    int[] pi = new int[n];
    for (int i = 0; i < n; ++i) {
        for (int k = 0; k <= i; ++k) {
            if (s.substring(0, k).equals(s.substring(i - k + 1, i + 1))) {
                pi[i] = k;
            }
        }
    }
    return pi;
}
```

Тривиальный алгоритм базируется на определении и имеет сложность ```O(n^3)```, где ```n``` - длина строки.

Перейдем к **эффективному алгоритму**:

1. Сразу присвоим ```pi[0] = 0```. Будем вычислять значения ```pi[i]``` по очереди — от ```i = 1``` до ```i = n - 1```.
2. Для подсчета ```pi[i]``` заведем переменную ```j``` - длину текущей подстроки. Изначально ```j = pi[i-1]```.
3. Сравним ```s[j]``` и ```s[i]```. Если совпадают, присваиваем ```pi[i] = j + 1``` и переходим к следующему индексу ```i + 1```. Если нет - уменьшаем длину ```j```: ```j = pi[j - 1]``` и повторяем шаг.
4. Если мы дошли до длины ```j = 0``` и так и не нашли совпадения, то полагаем ```pi[i] = 0``` и переходим к следующему индексу ```i + 1```.

Пример реализации эффективного алгоритма на Java: 

```java
public static int[] effectivePi(String s) {
    int n = s.length();
    int[] pi = new int[n];
    for (int i = 1; i < n; ++i) {
        int j = pi[i - 1];
        while (j > 0 && s.charAt(i) != s.charAt(j)) {
            j = pi[j - 1];
        }
        if (s.charAt(i) == s.charAt(j)) {
            ++j;
        }
        pi[i] = j;
    }
    return pi;
}
```

Внутри цикла ```for``` эффективного алгоритма все кроме ```while``` работает за константное время. Максимальное значение ```j``` - ```n - 1```. Внутри ```while``` ```j``` только уменьшается, значит ```j``` не может суммарно уменьшиться больше чем ```n - 1``` раз. Значит ```while``` выполнится не более ```n``` раз. Получаем итоговую оценку ```O(n)```.

### 3. Алгоритм Дейкстры. Постановка задачи, описание алгоритма за O(V<sup>2</sup> + E). Улучшение алгоритма для разреженных графов за O(E log V).

**Алгоритм Дейкстры** - это алгоритм нахождения кратчайшего пути от одной вершины до всех остальных вершин во взвешенном графе.

**Постановка задачи о кратчайших путях с единственным источником:**  
Дан ориентированный или неориентированный взвешенный граф, который содержит ```V``` вершин и ```E``` рёбер. Веса всех рёбер неотрицательны. Указана некоторая стартовая вершина ```s```. Требуется найти длины кратчайших путей из вершины ```s``` во все остальные вершины, а также предоставить способ вывода самых кратчайших путей.

**Алгоритм за ```O(V^2 + E)```:**

1. Создать массив расстояний до ```s``` - ```dist[]```. Изначально расстояние до стартовой вершины ```dist[s] = 0```, до остальных - бесконечности.
2. Создать массив посещенных вершин - ```visited[]```. Изначально все вершины не посещены (для любой вершины ```v``` верно ```visited[v] = false```).
3. Пока не все вершины посещены, повторять следующие шаги:
- Найти не посещенную вершину ```x```, расстояние до которой минимально.
- Пометить вершину ```x``` как посещенную.
- Обновить значения расстояний до всех смежных вершин ```y```, не посещенных ранее: ```dist[y] = min(dist[y], dist[x] + weight(x, y))```, где ```weight(x, y)``` - вес ребра между ```x``` и ```y```.

После работы данного алгоритма в массиве ```dist``` будут храниться кратчайшие пути из ```s``` в каждую из вершин.

Улучшенная версия алгоритма Дейкстры использует min-heap для эффективного выбора вершины с наименьшим расстоянием на каждой итерации. Вместо последовательного поиска вершины с минимальным расстоянием, мы будем использовать min-heap, чтобы выбрать вершину с наименьшим значением ```dist``` быстрее.

### 4. Динамическое программирование. Основные понятия. Задача о кузнечике. Задача о черепашке.

**Динамическое программирование** - это метод решения сложных задач путем разбиения на более простые подзадачи. **Подзадачи** представляют собой отдельные части задачи, которые могут быть решены независимо друг от друга.

**Оптимальная подструктура** - свойство задачи, подразумевающее, что ее оптимальное решение может быть выражено через оптимальные решения ее подзадач. Не все задачи обладают оптимальной подструктурой. Динамическое программирование подходит для решения задач, у которых такая структура есть.

**Перекрывающиеся подзадачи** - подзадачи, которые используются для решения *нескольких* задач большего размера.

**Мемоизация** - сохранение результатов выполнения функций для предотвращения повторных вычислений. Мемоизация применяется для увеличения скорости выполнения программы.

**Задача о кузнечике:**  
Кузнечик находится на левом краю прямой числовой оси и должен достичь правого края. Кузнечик может прыгать вперед на 1 шаг или на 2 шага. Требуется определить количество возможных способов, которыми кузнечик может достичь правого края. Эта задача решается с использованием динамического программирования путем нахождения рекуррентной формулы и заполнения таблицы значений для подзадач.

**Задача о черепашке:**  
Черепашка находится в верхнем левом углу сетки размером MxN. Черепашка может двигаться только вправо или вниз. Требуется определить количество возможных путей, которыми черепашка может достичь правого нижнего угла сетки. Эта задача также решается с использованием динамического программирования путем заполнения таблицы значений для подзадач.

### 5. Задача о рюкзаке: постановка классической задачи, решение методом динамического программирования, оценка времени работы.


### 6. Задача поиска наибольшей возрастающей подпоследовательности в массиве. Решение за O(N<sup>2</sup>) методом динамического программирования. Решение за O(N log N) методом динамического программирования.
### 7. Задача поиска длины наибольшей общей подпоследовательности двух строк. Решение за O(N * M) методом динамического программирования.

### 8. Поиск суммы на отрезке + изменение значения в массиве. Постановка задачи, решение за O(log N) при помощи дерева отрезков. Построение дерева отрезков.

**Постановка задачи:**  
Дан массив ```a```, содержащий ```n``` элементов. Необходимо обрабатывать запросы двух типов: запрос суммы (находить сумму элементов с ```l``` до ```r```) и запрос модификации (изменять значение указанного элемента массива).

Будем решать задачу при помощи дерева отрезков. Дерево отрезков - это бинарное дерево, которое представляет собой структуру данных для эффективной работы с операциями на отрезках последовательности элементов, в данном случае массива. Структура дерева отрезков основана на разбиении исходного массива на непересекающиеся отрезки и представлении каждого отрезка в виде узла дерева. Корень дерева представляет собой весь массив, а каждый узел соответствует отрезку, который является объединением отрезков, представленных его двумя дочерними узлами.

Сначала рассмотрим процесс построения дерева отрезков для решения данной задачи. По заданному массиву дерево отрезков удобно строить снизу вверх: сначала запишем значения элементов a[i] в соответствующие листья дерева, затем на их основе посчитаем значения для вершин предыдущего уровня как **сумму значений** в двух листьях, затем ещё одного, и так далее. В коде это можно реализовать в виде рекурсивной функции.

Перейдем к поиску суммы на отрезке. На вход поступает 2 числа ```l``` и ```r``` - индексы начала и конца отрезка.

### 9. Поиск минимума на отрезке + изменение значения в массиве. Постановка задачи, решение за O(log N) при помощи дерева отрезков. Построение дерева отрезков.
### 10. Алгоритм Форда-Беллмана. Описание алгоритма. Оценка времени выполнения.
### 11. Алгоритм Флойда-Уоршелла. Описание алгоритма. Оценка времени выполнения.
### 12. Двоичные деревья поиска. Описание структуры. Операции: постороения, удаления, вставки. Асимптотика операций.
