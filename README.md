Подготовка к устному зачету по курсу «Алгоритмы и структуры данных».

## Список билетов
### 1. Статический массив. Динамический массив, среднее время добавления элемента.
### 2. Односвязный список, двусвязный список. Псевдокод добавления и удаления.
### 3. АТД Стек. Реализация стека на основе дин. массива, на основе списка.
### 4. АТД Очередь и Дек. Реализация на основе списка, оценка времени сложности.

### 5. Бинарный поиск. Задача поиска элемента в отсортированном массиве - постановка задачи, оценка сложности алгоритма.
**Бинарный поиск** - алгоритм поиска объекта по заданному признаку в множестве объектов, упорядоченных по тому же самому признаку.

**Задача:** Дан упорядоченный массив, состоящий только из целочисленных элементов. Требуется найти позицию, на которой находится заданный элемент.

Идея заключается в том, что на каждом шаге множество объектов делится на две части и далее рассматривается только та часть, где находится искомый объект. На каждом шаге необходимо брать элемент в середине оставшегося массива и сравнивать его с искомым элементом. Если искомое больше середины, то середина становится левой границей. В противном случае - правой. Повторять нужно до тех пор, пока элемент не найден и разница между левой и правой границами больше 1.

```
 1.  int binSearch(int[] a, int key):    // ищем key
 2.      int l = -1                      // l - левая граница
 3.      int r = len(a)                  // r - правая граница   
 4.      while l < r - 1
 5.          m = (l + r) / 2             // m - середина области поиска
 6.          if a[m] < key
 7.              l = m
 8.          else 
 9.              r = m
10.      return r
```

Используя приведенный выше алгоритм, мы найдем самое левое вхождение искомого элемента. Это левосторонний бинарный поиск. Чтобы найти самое правое вхождение, нужно заменить условие в 6 строке на ```a[m] <= key``` и возвращать ```l```. Это правосторонний бинарный поиск.

Худший случай - если искомый элемент окажется первым или последним. Каждую итерацию мы делим массив пополам, Это значит, что сложность алгоритма будет зависеть от того, сколько раз мы можем поделить массив на двое - то есть в какую степень нужно возвести 2, чтобы получить длину рассматриваемого массива. Получаем сложность **O(log n)**.

### 6. Поддержка минимума в стеке и очереди.
### 7. Двоичная куча. Описание, построение, добавление элемента, извлечение минимума.
### 8. Квадратичные сортировки (пузырьком, вставками, выбором), сортировка с помощью двоичной кучи. Описание алгоритмов, оценка времени работы и дополнительной памяти.
### 9. Сортировка слиянием. Описание алгоритма, оценка времени работы
### 10. Быстрая сортировка. Описание алгоритма, оценка времени работы в лучшем, среднем и худшем случае.
### 11. Поиск k-ой порядковой статистики на основе быстрой сортировки. Оценка времени работы и лучшем, среднем и худшем случае.
### 12. Граф. Хранение графа в памяти: список смежности, матрица смежности (плюсы и минусы). Оценка времени поиска всех соседей, добавление ребра. Оценка расходуемой памяти.
### 13. Виды графов. Деревья. Связность. Циклы. Полные графы. Ориентированность.
### 14. Обход графа в ширину. Описание алгоритма, примеры задач, временная сложность.
### 15. Обход графа в глубину. Описание алгоритма, примеры задач, временная сложность. Свойство дерева обхода.
### 16. Поиск цикла в графе (ориентированном и неориентированном) при помощи обхода в глубину. Описание алгоритма, оценка по времени и памяти.
### 17. Поиск мостов в графе. Определение моста. Алгоритм нахождения мостов.
### 18. Поиск точек сочленения в графе. Определение точки сочленения. Алгоритм нахождения точек сочленения.
