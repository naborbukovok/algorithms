Подготовка к устному зачету по курсу «Алгоритмы и структуры данных».

## Список билетов
### 1. Статический массив. Динамический массив, среднее время добавления элемента.
**Массив** - набор однотипных элементов, доступ к которым осуществляется по индексу. В памяти массив представляется непрерывным куском. 

Массив, который не изменяет свой размер, называется **статическим**. Для статического массива размер задается при его инициализации.

**Динамический** массив - такой массив, который может изменять свой размер в зависимости от количества элементов в нём. Есть несколько способов добавить элемент в динамический массив.

**1) В конец:** Если в массиве есть место для добавления нового элемента (физическое), то добавление по индексу ```n``` происходит за константное время ```O(1)```. В худшем случае, если в массиве больше нет места, создается новый массив в несколько раз большей длины, в который копируются все элементы и далее по индексу ```n``` добавляется новый. Для худшего случая получаем сложность ```O(n)```, так как копируем каждый из ```n``` элементов. Однако, так как при отсутствии места длина массива увеличивается не на 1, а в несколько раз, среднее время добавления элемента в конец массива будет ```O(1)```.

**2) В начало:** Если место есть, то каждый из элементов, начиная с конца, смещается на 1 вправо, а затем в начало добавляется новый элемент. Если места нет, создается новый массив в несколько раз большей длины, в котрый копируются все значения исходного массива со сдвигом вправо на 1, а затем в начало добавляется новый элемент. В обоих случаях сложность линейная - ```O(n)```. То есть среднее время добавления элемента в начало массива - так же ```O(n)```.

**3) В произвольное место:** Алгоритм и сложность аналогичны добавлению в начало (за исключением того, что в данном случае сдвигаются не все элементы).

### 2. Односвязный список, двусвязный список. Псевдокод добавления и удаления.
**Односвязный список** - структура данных, состоящая из элементов (узлов), содержащих помимо собственных данных указатель на следующий элемент в списке.

**Двусвязный список** - структура данных, состоящая из элементов (узлов), содержащих помимо собственных данных указатели на предыдущий и следующий элемент в списке. Благодаря этоик становится проще удалять и переставлять элементы.

**Вставка в односвязном списке:**
1. Создаем новый узел
2. Находим в списке место для вставки (можно отсчиать от head)
3. Новому узлу назначаем ссылку на следующий, а текущему на новый

В общем случае сложность вставки в односвязном списке ```O(n)```, для добавления в начало или в конец ```O(1)```.

**Удаление в односвязном списке:**
1. Ищем в списке узел, который находится перед удаляемым
2. Назначаем этому узлу ссылку, которую хранил удаляемый (то есть следующий)

При удалении важно обратить внимание на крайние случаи: элемента нет в списке, элемент один, элемент находится в начале или в конце списка. Сложность удаления - ```O(n)``` (в худшем случае переберем все элементы и не найдем тот, что нужно удалить).

**Вставка и удаление в двусвязном списке** идейно похожи, добавляется только переназначение указателя на предыдущий узел. Сложность та же.

Двусвязный список, в отличие от односвязного, позволяет вручную итерироваться по списку в обе стороны. На основе связных списков строятся другие, более сложные, структуры данных.

### 3. АТД Стек. Реализация стека на основе дин. массива, на основе списка.
### 4. АТД Очередь и Дек. Реализация на основе списка, оценка времени сложности.

### 5. Бинарный поиск. Задача поиска элемента в отсортированном массиве - постановка задачи, оценка сложности алгоритма.
**Бинарный поиск** - алгоритм поиска объекта по заданному признаку в множестве объектов, упорядоченных по тому же самому признаку.

**Задача:** Дан упорядоченный массив, состоящий только из целочисленных элементов. Требуется найти позицию, на которой находится заданный элемент.

Идея заключается в том, что на каждом шаге множество объектов делится на две части и далее рассматривается только та часть, где находится искомый объект. На каждом шаге необходимо брать элемент в середине оставшегося массива и сравнивать его с искомым элементом. Если искомое больше середины, то середина становится левой границей. В противном случае - правой. Повторять нужно до тех пор, пока элемент не найден и разница между левой и правой границами больше 1.

```
 1.  int binSearch(int[] a, int key):    // ищем key
 2.      int l = -1                      // l - левая граница
 3.      int r = len(a)                  // r - правая граница   
 4.      while l < r - 1
 5.          m = (l + r) / 2             // m - середина области поиска
 6.          if a[m] < key
 7.              l = m
 8.          else 
 9.              r = m
10.      return r
```

Используя приведенный выше алгоритм, мы найдем самое левое вхождение искомого элемента. Это левосторонний бинарный поиск. Чтобы найти самое правое вхождение, нужно заменить условие в 6 строке на ```a[m] <= key``` и возвращать ```l```. Это правосторонний бинарный поиск.

Худший случай - если искомый элемент окажется первым или последним. Каждую итерацию мы делим массив пополам, Это значит, что сложность алгоритма будет зависеть от того, сколько раз мы можем поделить массив на двое - то есть в какую степень нужно возвести 2, чтобы получить длину рассматриваемого массива. Получаем сложность ```O(log n)```.

### 6. Поддержка минимума в стеке и очереди.
### 7. Двоичная куча. Описание, построение, добавление элемента, извлечение минимума.
### 8. Квадратичные сортировки (пузырьком, вставками, выбором), сортировка с помощью двоичной кучи. Описание алгоритмов, оценка времени работы и дополнительной памяти.
### 9. Сортировка слиянием. Описание алгоритма, оценка времени работы
### 10. Быстрая сортировка. Описание алгоритма, оценка времени работы в лучшем, среднем и худшем случае.
### 11. Поиск k-ой порядковой статистики на основе быстрой сортировки. Оценка времени работы и лучшем, среднем и худшем случае.
### 12. Граф. Хранение графа в памяти: список смежности, матрица смежности (плюсы и минусы). Оценка времени поиска всех соседей, добавление ребра. Оценка расходуемой памяти.
### 13. Виды графов. Деревья. Связность. Циклы. Полные графы. Ориентированность.
### 14. Обход графа в ширину. Описание алгоритма, примеры задач, временная сложность.
### 15. Обход графа в глубину. Описание алгоритма, примеры задач, временная сложность. Свойство дерева обхода.
### 16. Поиск цикла в графе (ориентированном и неориентированном) при помощи обхода в глубину. Описание алгоритма, оценка по времени и памяти.
### 17. Поиск мостов в графе. Определение моста. Алгоритм нахождения мостов.
### 18. Поиск точек сочленения в графе. Определение точки сочленения. Алгоритм нахождения точек сочленения.
